/* 
 This file was generated by Dashcode.  
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{
	dashcode.setupParts();
	loadPrefs();
	versionCheck();
}

//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
	// Stop any timers to prevent CPU usage
	// Remove any preferences as needed
	// widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
	erasePrefs();
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
	// Stop any timers to prevent CPU usage
	savePrefs();
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
	// Restart any timers that were stopped on hide
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
	// Retrieve any preference values that you need to be synchronized here
	// Use this for an instance key's value:
	// instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
	//
	// Or this for global key's value:
	// globalPreferenceValue = widget.preferenceForKey(null, "your-key");
}

//
// Function: showBack(event)
// Called when the info button is clicked to show the back of the widget
//
// event: onClick event from the info button
//
function showBack(event)
{
	var front = document.getElementById("front");
	var back = document.getElementById("back");

	if (window.widget) {
		widget.prepareForTransition("ToBack");
	}

	front.style.display = "none";
	back.style.display = "block";

	if (window.widget) {
		setTimeout('widget.performTransition();', 0);
	}
}

//
// Function: showFront(event)
// Called when the done button is clicked from the back of the widget
//
// event: onClick event from the done button
//
function showFront(event)
{
	var front = document.getElementById("front");
	var back = document.getElementById("back");

	if (window.widget) {
		widget.prepareForTransition("ToFront");
		updatePrefs();
	}

	front.style.display="block";
	back.style.display="none";

	if (window.widget) {
		setTimeout('widget.performTransition();', 0);
	}
}

if (window.widget) {
	widget.onremove = remove;
	widget.onhide = hide;
	widget.onshow = show;
	widget.onsync = sync;
}

// Begin app-specific functions

var wid = widget.identifier;
var prefFPS = loadPref(wid+"fps",30);
var prefKeyframe = loadPref(wid+"keyframe",0);

// Preference Saving

function loadPref(key,value) {
	var string = widget.preferenceForKey(key);
	if (string != null) {
		return string;
	} else {
		widget.setPreferenceForKey(value,key);
		return value;
	}
}

function loadPrefs() {
//	document.getElementById("fps").value = prefFPS;
//	document.getElementById("keyframe").object.setSelectedIndex(prefKeyframe);
}

function savePref(key,value) {
	if (window.widget) {
		widget.setPreferenceForKey(value,wid+key);
	}
}

function updatePrefs() {
	if (window.widget) {
//		widget.setPreferenceForKey(prefFPS,wid+"fps");
//		widget.setPreferenceForKey(prefKeyframe,wid+"keyframe");
	}
}

function erasePrefs() {
	if (window.widget) {
//		widget.setPreferenceForKey(null,wid+"fps");
//		widget.setPreferenceForKey(null,wid+"keyframe");
	}
}

// Basic Functions

function updateH(event) {
	// Insert Code Here
}

function updateS(event) {
	// Insert Code Here
}

function updateV(event) {
	// Insert Code Here
}

function updateR(event) {
	// Insert Code Here
}


function updateG(event) {
	// Insert Code Here
}

function updateB(event) {
	// Insert Code Here
}

function updateHEX(event) {
	// Insert Code Here
}





function updateFPS(event) {
	var fps = document.getElementById("fps");
	prefFPS = parseInt(fps.value);
//	fps.value = prefFPS+"fps";

	if (event.type == "keyup") {
		if (event.keyCode == "13" || event.keyCode == "38" || event.keyCode == "40") {
			fps.value = prefFPS+"fps";
//			fps.focus();
//			fps.select();
			selectIt(fps);
		}
	} else {
		fps.value = prefFPS+"fps";
	}
}

function updateKeyframe(event) {
	prefKeyframe = document.getElementById("keyframe").object.getSelectedIndex();
}

function updatePhoneme(event) {
	prefPhoneme = document.getElementById("phoneme").object.getSelectedIndex();
	alert("prefPhoneme = "+prefPhoneme);
	if (prefPhoneme > 1) {
		var preset = "preset"+(prefPhoneme-1);
		prefPhonemeString = document.getElementById(preset).value;
		alert("prefPhonemeString = "+prefPhonemeString);
	} else if (prefPhoneme == 1) {
		prefPhonemeString = Flash;
		alert("prefPhonemeString = "+prefPhonemeString);
	} else {
		prefPhonemeString = PrestonBlair;
		alert("prefPhonemeString = "+prefPhonemeString);
	}
	updatePrefs();
}

function updatePreset(event) {
//	var fps = document.getElementById("fps");
//	prefKeyframe = parseFloat(fps.value);
}

// Be sure to assign these handlers for the ondragenter and ondragover events on your drop target. These handlers prevent Web Kit from processing drag events so you can handle the drop when it occurs.

function dragEnter(event) {
	event.stopPropagation();
	event.preventDefault();
}

function dragOver(event) {
	event.stopPropagation();
	event.preventDefault();
}

function dragDrop(event) {
	try {
		uri = event.dataTransfer.getData("text/uri-list");	
		uri = uri.replace(/file:\/\/localhost/, "");
		uri = uri.replace(/\%20/g, "\\ ");
		uri = uri.replace(/\n/g, " ");

		widget.system("cat "+uri, processInput).outputString;
	} catch (ex) {
		alert("Problem fetching URI: " + ex);
		showFail(event);
	}

	event.stopPropagation();
	event.preventDefault();
}

function processInput(event) {
	input = event.outputString.replace(/\r\n|\n|\r/gi," ");

	if (input.search(/MohoSwitch/i)<0) {
		return showWrong(event);
	}

	var string = prefPhonemeString.split(',');
	var keytype = document.getElementById("keyframe").object.getValue();
	var keydex = document.getElementById("keyframe").object.getSelectedIndex();

	if (keydex >= 4) {
		keyframeAE(string,keytype)
	} else {
		for(var i in string) {
			keyframeLW(string[i],keytype);
		}
	}
}

function keyframeLW(phoneme,keytype) {
	var a1 = input.split(" ");
	var len = a1.length-1;
	var len2 = Math.round((len/2)-0.25);
	var output = "	" + len2 + "\n";
	for (i=0;i<len;i++){
		if (i%2==1){
		var a2 = a1[i+1];
			if (a2 == phoneme) {
			var keyvalue = "1";
			} else {
			var keyvalue = "0";
			}
		output = output + "	 Key " + keyvalue + " " + (a1[i]/prefFPS) + keytype + " 0 0 0 0 0\n";
		}
	}

	var myCommand = widget.system("cat > "+uri+"."+phoneme+".env", endHandler);
	myCommand.write("{ Envelope\n"+output+"	 Behaviors 1 1\n}");
	myCommand.close();

	return	showSuccess();
}

function endHandler(event) {
}

// Clipboard

function copy(value){
	widget.system("/usr/bin/osascript -e 'set the clipboard to \"" + value + "\"'", null);
}

// Key listeners

function keyboard(event) {
	var data = parseFloat(event.target.value);
	if (event.keyCode == 38) {
		if (event.shiftKey == true) {
			event.target.value = data+10
		} else {
			event.target.value = data+1
		}
		return true;
	} else if (event.keyCode == 40) {
		if (event.shiftKey == true) {
			event.target.value = data-10
		} else {
			event.target.value = data-1
		}
		return true;
	} else {
		return true;
	}
}

function selectIt(event) {
	if(event.target){
		event = event.target
	}
//	event.focus();
	event.select();
}



// Conversion Processes

/*
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 */
function RGBtoHSL(r, g, b){
	r /= 255, g /= 255, b /= 255;
	var max = Math.max(r, g, b), min = Math.min(r, g, b);
	var h, s, l = (max + min) / 2;

	if(max == min){
		h = s = 0; // achromatic
	}else{
		var d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch(max){
			case r: h = (g - b) / d + (g < b ? 6 : 0); break;
			case g: h = (b - r) / d + 2; break;
			case b: h = (r - g) / d + 4; break;
		}
		h /= 6;
	}

	return [h, s, l];
}

/*
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 */
function HSLtoRGB(h, s, l){
	var r, g, b;

	if(s == 0){
		r = g = b = l; // achromatic
	}else{
		function hue2RGB(p, q, t){
			if(t < 0) t += 1;
			if(t > 1) t -= 1;
			if(t < 1/6) return p + (q - p) * 6 * t;
			if(t < 1/2) return q;
			if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
			return p;
		}

		var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		var p = 2 * l - q;
		r = hue2RGB(p, q, h + 1/3);
		g = hue2RGB(p, q, h);
		b = hue2RGB(p, q, h - 1/3);
	}

	return [r * 255, g * 255, b * 255];
}

/*
 * Converts an RGB color value to HSV. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and v in the set [0, 1].
 */
function RGBtoHSV(r, g, b){
	r = r/255, g = g/255, b = b/255;
	var max = Math.max(r, g, b), min = Math.min(r, g, b);
	var h, s, v = max;

	var d = max - min;
	s = max == 0 ? 0 : d / max;

	if(max == min){
		h = 0; // achromatic
	}else{
		switch(max){
			case r: h = (g - b) / d + (g < b ? 6 : 0); break;
			case g: h = (b - r) / d + 2; break;
			case b: h = (r - g) / d + 4; break;
		}
		h /= 6;
	}

	return [h, s, v];
}

/*
 * Converts an HSV color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes h, s, and v are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 */
function HSVtoRGB(h, s, v){
	var r, g, b;

	var i = Math.floor(h * 6);
	var f = h * 6 - i;
	var p = v * (1 - s);
	var q = v * (1 - f * s);
	var t = v * (1 - (1 - f) * s);

	switch(i % 6){
		case 0: r = v, g = t, b = p; break;
		case 1: r = q, g = v, b = p; break;
		case 2: r = p, g = v, b = t; break;
		case 3: r = p, g = q, b = v; break;
		case 4: r = t, g = p, b = v; break;
		case 5: r = v, g = p, b = q; break;
	}

	return [r * 255, g * 255, b * 255];
}



alert(RGBtoHEX([255,128,20]));

function RGBtoHEX(rgb) {
	var hex = [];
	hex[0] = DECtoHEX(rgb[0]);
	hex[1] = DECtoHEX(rgb[1]);
	hex[2] = DECtoHEX(rgb[2]);

	return (hex[0]+""+hex[1]+""+hex[2]).toUpperCase();
}

function DECtoHEX(dec) {
	return dec.toString(16);
}



alert("#FD8012 = "+HEXtoRGB("FF8014"));

function HEXtoRGB(hex) {
	var r = HEXtoDEC(hex.substring(0,2));
	var g = HEXtoDEC(hex.substring(2,4));
	var b = HEXtoDEC(hex.substring(4,6));
	return [r, g, b];
}

function HEXtoDEC(hex) {
	return parseInt(hex, 16);
}

//var test = document.getElementById('swatch').style.backgroundColor = "#"+RGBtoHEX([255,20,20]);
var test = swatch.style.backgroundColor;

var test2 = document.getElementById('swatch').style.background-color: rgb(111, 111, 111);



// CurrentView animations

function showMain(event) {
	document.getElementById("stack").object.setCurrentView("main", false, true);
}

function showSuccess(event) {
	document.getElementById("stack").object.setCurrentView("success", true, true);
}

function showFail(event) {
	document.getElementById("stack").object.setCurrentView("fail", true, true);
}

function showWrong(event) {
	document.getElementById("stack").object.setCurrentView("wrong", true, true);
}

function showUpdate(event) {
	document.getElementById("stack").object.setCurrentView("update", true, true);
}

// Other animations

function showAddButton(event) {
	var itemToFadeIn = document.getElementById("add");
	var fadeHandler = function(a, c, s, f){ itemToFadeIn.style.opacity = c; };
	new AppleAnimator(200, 5, 0.1, 0.5, fadeHandler).start();
}

function hideAddButton(event) {
	var itemToFadeIn = document.getElementById("add");
	var fadeHandler = function(a, c, s, f){ itemToFadeIn.style.opacity = c; };
	new AppleAnimator(400, 10, 0.5, 0.1, fadeHandler).start();
}

// Get Key Value

function getKeyValue(plist, key) {
	var infoPlist = new XMLHttpRequest();
	infoPlist.open("GET", plist, false);
	infoPlist.send(null);
	infoPlist = infoPlist.responseText.replace(/(<([^>]+)>)/ig,"").replace(/\t/ig,"").split("\n");
	for (var i=0; i<infoPlist.length; i++)
		if (infoPlist[i] == key) return infoPlist[i+1];
	return false;
}

// Auto Update

function versionCheck(event) {

return
// REMOVE THE ABOVE LINE OR AUTO UPDATE WILL BE BROKEN
// REMOVE THE ABOVE LINE OR AUTO UPDATE WILL BE BROKEN
// REMOVE THE ABOVE LINE OR AUTO UPDATE WILL BE BROKEN
// REMOVE THE ABOVE LINE OR AUTO UPDATE WILL BE BROKEN

	var request = new XMLHttpRequest();
	var address = "http://iaian7.com/files/dashboard/chroma/version.php?RandomKey=" + Date.parse(new Date());
	alert(address);
	request.open("GET", address,false);
	request.send(null);
	var versions = request.responseText.split("\n");

	var bundleVersion = getKeyValue("Info.plist", "CFBundleVersion"); 
	var websiteVersion = versions[0];
	alert("bundleVersion: "+bundleVersion);
	alert("websiteVersion: "+websiteVersion);

	if (websiteVersion != bundleVersion) {
		document.getElementById("newVersion").innerHTML = "version "+versions[0]+"<br/>"+versions[1];
		showUpdate();
	} else {
		alert("you have an up to date version, or there's been an error");
	}
}

// Download File

function versionDownload() {
	widget.openURL("http://iaian7.com/files/dashboard/chroma/Chroma.zip");
	showMain();
}

// Visit the website

function iaian7(event)
{
	widget.openURL("http://iaian7.com/dashboard/chroma");
}