/*
 This file was generated by Dashcode.
 You may edit this file to customize your widget or web page
 according to the license.txt file included in the project.
 */

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{
	dashcode.setupParts();
	versionCheck();
	loadPrefs();
	processLibrary();
}

//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
	// Stop any timers to prevent CPU usage
	// Remove any preferences as needed
	// widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
	erasePrefs();
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
	// Stop any timers to prevent CPU usage
	updateScroll();
	updatePrefs();
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
	// Restart any timers that were stopped on hide
	updatePrefs();
//	processLibrary();
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
	// Retrieve any preference values that you need to be synchronized here
	// Use this for an instance key's value:
	// instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
	//
	// Or this for global key's value:
	// globalPreferenceValue = widget.preferenceForKey(null, "your-key");
}

//
// Function: showBack(event)
// Called when the info button is clicked to show the back of the widget
//
// event: onClick event from the info button
//
function showBack(event)
{
	updateScroll();
	var front = document.getElementById("front");
	var back = document.getElementById("back");

	if (window.widget) {
		widget.prepareForTransition("ToBack");
	}

	front.style.display = "none";
	back.style.display = "block";

	if (window.widget) {
		setTimeout('widget.performTransition();', 0);
	}
}

//
// Function: showFront(event)
// Called when the done button is clicked from the back of the widget
//
// event: onClick event from the done button
//
function showFront(event)
{
	var front = document.getElementById("front");
	var back = document.getElementById("back");

	if (window.widget) {
		widget.prepareForTransition("ToFront");
		updatePrefs();
		processLibrary();
	}

	front.style.display="block";
	back.style.display="none";

	if (window.widget) {
		setTimeout('widget.performTransition();', 0);
	}
}

if (window.widget) {
	widget.onremove = remove;
	widget.onhide = hide;
	widget.onshow = show;
	widget.onsync = sync;
}

// Begin app-specific functions

var wid = widget.identifier;
var pref = [];
pref[2] = loadPref(wid+"H",30);
pref[3] = loadPref(wid+"S",0.9);
pref[4] = loadPref(wid+"V",1.0);
pref[5] = loadPref(wid+"R",1.000000000);
pref[6] = loadPref(wid+"G",0.549019608);
pref[7] = loadPref(wid+"B",0.098039216);
pref[8] = loadPref(wid+"X","FF8C19");
prefLibrary = loadPref(wid+"library",[["grayscale", "black", 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, "000000", 23], ["grayscale", "gray", 0.0, 0.0, 0.5, 0.5, 0.5, 0.5, "656565", 3], ["grayscale", "white", 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, "FFFFFF", 4], ["group", "orange", 30, 0.9, 1.0, 1.000000000, 0.549019608, 0.098039216, "FF8C19", 1]]);
prefSort = loadPref(wid+"sort",0);
prefShow = loadPref(wid+"show",0);
prefFormatHSV = loadPref(wid+"formatHSV",0);
prefFormatRGB = loadPref(wid+"formatRGB",0);
prefAccuracy = loadPref(wid+"accuracy",1);
prefGroup = loadPref(wid+"group","group");
prefName = loadPref(wid+"name","name");
prefScroll = loadPref(wid+"scroll",0);



// Preference Saving

function loadPref(key,value) {
	var string = widget.preferenceForKey(key);
	if (string != null) {
		return string;
	} else {
		widget.setPreferenceForKey(value,key);
		return value;
	}
}

function loadPrefs() {
	document.getElementById("sort").object.setSelectedIndex(prefSort);
	document.getElementById("show").object.setSelectedIndex(prefShow);
	document.getElementById("formatHSV").object.setSelectedIndex(prefFormatHSV);
	document.getElementById("formatRGB").object.setSelectedIndex(prefFormatRGB);
	document.getElementById("accuracy").object.setSelectedIndex(prefAccuracy);
	updateAll();
}

function updatePrefs() {
	if (window.widget) {
		widget.setPreferenceForKey(pref[2],wid+"H");
		widget.setPreferenceForKey(pref[3],wid+"S");
		widget.setPreferenceForKey(pref[4],wid+"V");
		widget.setPreferenceForKey(pref[5],wid+"R");
		widget.setPreferenceForKey(pref[6],wid+"G");
		widget.setPreferenceForKey(pref[7],wid+"B");
		widget.setPreferenceForKey(pref[8],wid+"X");
		widget.setPreferenceForKey(prefSort,wid+"library");
		widget.setPreferenceForKey(prefSort,wid+"sort");
		widget.setPreferenceForKey(prefShow,wid+"show");
		widget.setPreferenceForKey(prefFormatHSV,wid+"formatHSV");
		widget.setPreferenceForKey(prefFormatRGB,wid+"formatRGB");
		widget.setPreferenceForKey(prefAccuracy,wid+"accuracy");
		widget.setPreferenceForKey(prefGroup,wid+"group");
		widget.setPreferenceForKey(prefName,wid+"name");
		widget.setPreferenceForKey(prefScroll,wid+"scroll");
	}
}

function erasePrefs() {
	if (window.widget) {
		widget.setPreferenceForKey(null,wid+"H");
		widget.setPreferenceForKey(null,wid+"S");
		widget.setPreferenceForKey(null,wid+"V");
		widget.setPreferenceForKey(null,wid+"R");
		widget.setPreferenceForKey(null,wid+"G");
		widget.setPreferenceForKey(null,wid+"B");
		widget.setPreferenceForKey(null,wid+"X");
		widget.setPreferenceForKey(null,wid+"library");
		widget.setPreferenceForKey(null,wid+"sort");
		widget.setPreferenceForKey(null,wid+"show");
		widget.setPreferenceForKey(null,wid+"formatHSV");
		widget.setPreferenceForKey(null,wid+"formatRGB");
		widget.setPreferenceForKey(null,wid+"accuracy");
		widget.setPreferenceForKey(null,wid+"group");
		widget.setPreferenceForKey(null,wid+"name");
		widget.setPreferenceForKey(null,wid+"scroll");
	}
}

// Basic Functions

function updateAll(event) {
	if (event != "HSV") {
		document.getElementById("H").value = parseH(pref[2]);
		document.getElementById("S").value = parseSV(pref[3]);
		document.getElementById("V").value = parseSV(pref[4]);
	}
	if (event != "RGB") {
		document.getElementById("R").value = parseRGB(pref[5]);
		document.getElementById("G").value = parseRGB(pref[6]);
		document.getElementById("B").value = parseRGB(pref[7]);
	}
	if (event != "HEX") {
		document.getElementById("X").value = "#"+pref[8];
	}
	if (document.getElementById("swatch")) document.getElementById("swatch").style.backgroundColor = "#"+pref[8];
	if (document.getElementById("swatchSave")) document.getElementById("swatchSave").style.backgroundColor = "#"+pref[8];

	document.getElementById("groupTitle").value = prefGroup;
	document.getElementById("nameTitle").value = prefName;
}

function updateSort(event) {
	prefSort = document.getElementById("sort").object.getSelectedIndex();
}

function updateShow(event) {
	prefShow = document.getElementById("show").object.getSelectedIndex();
}

function updateFormatHSV(event) {
	prefFormatHSV = document.getElementById("formatHSV").object.getSelectedIndex();
}

function updateFormatRGB(event) {
	prefFormatRGB = document.getElementById("formatRGB").object.getSelectedIndex();
}

function updateAccuracy(event) {
	prefAccuracy = document.getElementById("accuracy").object.getSelectedIndex();
}

function updateGroup(event) {
	prefGroup = document.getElementById("groupTitle").value;
}

function updateName(event) {
	prefName = document.getElementById("nameTitle").value;
}

function updateScroll() {
	prefScroll = document.getElementById("scrollArea").object.content.scrollTop;
	widget.setPreferenceForKey(prefScroll,wid+"scroll");
}

function updateScrollArea() {
	var scrollArea = document.getElementById("scrollArea").object;
	scrollArea.refresh();
	scrollArea.verticalScrollTo(prefScroll);
}



// Keyboard input

function updateInput(event) {
	var data = parseFloat(event.target.value);
	var dataFrom = data;
	var prefId = 8;
	var increment = (prefFormatRGB==0)? 0.015625 : 0.01; // 4/256
	var incrementShift = (prefFormatRGB==0)? 0.0625 : 0.1; // 16/256

	switch (event.target.id) {
	case "H":
		prefId = 2;
		dataFrom = fromH(data);
		increment = 1;
		incrementShift = 10;
		break;
	case "S":
		prefId = 3;
		dataFrom = fromSV(data);
		increment = (prefFormatHSV==1)? 0.015625 : 0.01;
		incrementShift = (prefFormatHSV==1)? 0.0625 : 0.1;
		break;
	case "V":
		prefId = 4;
		dataFrom = fromSV(data);
		increment = (prefFormatHSV==1)? 0.015625 : 0.01;
		incrementShift = (prefFormatHSV==1)? 0.0625 : 0.1;
		break;
	case "R":
		prefId = 5;
		dataFrom = fromRGB(data);
		break;
	case "G":
		prefId = 6;
		dataFrom = fromRGB(data);
		break;
	case "B":
		prefId = 7;
		dataFrom = fromRGB(data);
		break;
	default:
		prefId = 8;
		increment = false;
		incrementShift = false;
		data = event.target.value.match(/([0-9a-f]{6})/i);
//		data = event.target.value.match(/^#?([0-9a-f]{6})$/i);
		if (data && event.keyCode>40) {
			pref[8] = data[1].replace("#","").toUpperCase();	// removes hashtag before saving to the preferences
			if (!data[0].match("#")) event.target.value = "#"+pref[8];	// adds hashtag to display if not included already
			HEXtoRGB();
			RGBtoHSV();
//			return updateAll("HEX");
			updateAll("HEX");
			return selectIt(event.target);
		} else {
			return false;
		}
	}

	if (event.keyCode == 38 && increment) {			// If arrow keys are used, load preference value and adjust accordingly
		data = pref[prefId];
		data += (event.shiftKey == true)?incrementShift:increment;
	} else if (event.keyCode == 40 && increment) {	//
		data = pref[prefId];
		data -= (event.shiftKey == true)?incrementShift:increment;
	} else if (pref[prefId] == dataFrom) {			// Prevent constant updates simply from non-entry key presses
		return false;
	} else if (data>=0) {							// If straight numbers are entered, convert to preference value and update
		if (prefId == 2){
			data = fromH(data);
		} else if (prefId <= 4) {
			data = fromSV(data);
		} else {
			data = fromRGB(data);
		}
	} else {
		data = pref[prefId];
		alert("invalid text field input");
	}

	// rollover Hue, or limit to 1.0 floating point value
	if (prefId == 2) {
		data = data%360;
	} else if (data > 1) {
		data = 1.0;
	}

	if (data < 0) {
		data = 0;
	}

	pref[prefId] = data;

	if (prefId <= 4) {
		HSVtoRGB();
		RGBtoHEX();
//		return updateAll("HSV");
	} else {
		RGBtoHSV();
		RGBtoHEX();
//		return updateAll("RGB");
	}

//	return updateAll();
	updateAll();
//	return selectIt(event.target);
}



// Library processing

function addLibrary(event) {
	updateScroll();
	if (prefGroup.search(/[a-z]/i)<0 || prefName.search(/[a-z]/i)<0) return showAlert("add to library error");
	prefLibrary.push([prefGroup,prefName,pref[2],pref[3],pref[4],pref[5],pref[6],pref[7],pref[8],new Date().getTime()]);
	processLibrary();
	return showValues();
}

function editLibrary(event) {
	updateScroll();
	var del = event;
	del = arrayMatch(prefLibrary,9,del);
	if (del) prefLibrary.splice(del,1);
	return processLibrary();
}

function processLibrary(event) {
//	alert("Library 1 - prefLibrary:\n"+prefLibrary.join("\n"));

	libArray = arrayClean(prefLibrary);

//	alert("Library 2 - libArray:\n"+libArray.join("\n"));

	if (libArray[1]) {
		switch (prefSort) {
		case 1:
			libArray.sort(sortHue);
			break;
		case 2:
			libArray.sort(sortSaturation);
			break;
		case 3:
			libArray.sort(sortValue);
			break;
		case 4:
			libArray.sort(sortDate);
			break;
		default:
			libArray.sort(sortName);
		}
	}

	alert("Library 3 - sorted:\n"+libArray.join("\n"));

	libArray = arrayGroup(libArray);

	alert("Library 4 - grouped:\n"+libArray.join("\n"));

	listDataSource._rowData = libArray;
	list.object.reloadData();
	updateScrollArea();
	prefLibrary = libArray;
}

function fromLibrary(event) {
	prefGroup = event[0];
	prefName = event[1];
	pref[2] = event[2];
	pref[3] = event[3];
	pref[4] = event[4];
	pref[5] = event[5];
	pref[6] = event[6];
	pref[7] = event[7];
	pref[8] = event[8];
	updateAll();
}



// Array functions

function arrayMatch(arr,ind,str) {
	for(var i=0; i<arr.length; i++) {
		if (arr[i][ind] == str) return i;
	}
	return false;
}

function arraySearch(arr,str) {
	for(var i=0; i<arr.length; i++) {
//		alert("array index == "+i);
//		alert("array element == "+arr[i]);
//		if (arr[i] == str) return i;	// THIS CAN CAUSE AN ENDLESS LOOP OR CORRUPTION IN ANOTHER SECTION OF CODE!!!
		if (arr[i] == str) return true;
	}
	return false;
}

function arrayClean(arr) {
	var arr2 = [];
//	alert("array:\n"+arr.join("\n"));
	for(var i=0; i<arr.length; i++) {
		if (arr[i][9]) {
			arr2.push(arr[i]);
		}
	}
//	alert("arrayCleaned:\n"+arr2.join("\n"));
	return arr2;
}

function arrayGroup(arr) {
	var arr2 = [];
	var hold = "";
	for(var i=0; i<arr.length; i++) {
		if (arr[i][0] != hold) {
			hold = arr[i][0];
			arr2.push([arr[i][0]]);
		}
		arr2.push(arr[i]);
	}
	return arr2;
}

function arrayGroupsOLD(arr) {
	var arrGroup = [];
	for(var i=0; i<arr.length; i++) {
		if (!arraySearch(arrGroup,arr[i][0])) {
			arrGroup.push(arr[i][0]);
			arr.push([arr[i][0]]);
		}
	}
	return arr;
}



// Array sorting algorithms

function sortName(a, b) {
	var x = a[0].toLowerCase();
	var y = b[0].toLowerCase();
	if (x==y && !a[1]) { return -1; } else if (x==y && !b[1]) { return 1; }
	if (x==y) x = a[1].toLowerCase(), y = b[1].toLowerCase();
	return (x < y) ? -1 : ((x > y) ? 1 : 0);
}

function sortHue(a, b){
	var x = a[0].toLowerCase();
	var y = b[0].toLowerCase();
	if (x==y && !a[1]) { return -1; } else if (x==y && !b[1]) { return 1; }
	return (x < y) ? 1 : ((x > y) ? -1 : a[2] - b[2]);
}

function sortSaturation(a, b){
	var x = a[0].toLowerCase();
	var y = b[0].toLowerCase();
	if (x==y && !a[1]) { return -1; } else if (x==y && !b[1]) { return 1; }
	return (x < y) ? 1 : ((x > y) ? -1 : a[3] - b[3]);
}

function sortValue(a, b){
	var x = a[0].toLowerCase();
	var y = b[0].toLowerCase();
	if (x==y && !a[1]) { return -1; } else if (x==y && !b[1]) { return 1; }
	return (x < y) ? 1 : ((x > y) ? -1 : a[4] - b[4]);
}

function sortDate(a, b){
	if (x==y && !a[1]) { return -1; } else if (x==y && !b[1]) { return 1; }
	return a[9] - b[9];
}



// Clipboard

function copy(event,value){
	copyFlash(event);
	widget.system("/usr/bin/osascript -e 'set the clipboard to \"" + value + "\"'", null);
}

function copyHSV(event){
	copyFlashDim(event);
	var decimal = (prefAccuracy*2)+2;
	var tempHSV = parseH(pref[2])+" "+parseSV(pref[3])+" "+parseSV(pref[4]);
	var clipHSV = (prefFormatHSV==3)?(pref[2]).toFixed(decimal)+" "+(pref[3]).toFixed(decimal)+" "+(pref[4]).toFixed(decimal):tempHSV;
	widget.system("/usr/bin/osascript -e 'set the clipboard to \"" + clipHSV + "\"'", null);
}

function copyRGB(event){
	copyFlashDim(event);
	var decimal = (prefAccuracy*2)+2;
	var tempRGB = parseRGB(pref[5])+" "+parseRGB(pref[6])+" "+parseRGB(pref[7]);
	var clipRGB = (prefFormatRGB==3)?(pref[5]).toFixed(decimal)+" "+(pref[6]).toFixed(decimal)+" "+(pref[7]).toFixed(decimal):tempRGB;
	widget.system("/usr/bin/osascript -e 'set the clipboard to \"" + clipRGB + "\"'", null);
}

function copyHEX(event){
	copyFlashDim(event);
	var clipHEX = pref[8];
	widget.system("/usr/bin/osascript -e 'set the clipboard to \"" + clipHEX + "\"'", null);
}



// Key listeners

function selectIt(event) {
	if(event.target){
		event = event.target;
	}
//	event.focus();
	event.select();
}



//// LIST BOX

var _this = [];

// This object implements the dataSource methods for the list.
var listDataSource = {

	// Sample data for the content of the list.
	// Your application may also fetch this data remotely via XMLHttpRequest.
	_rowData: [["empty library"]],

	// The List calls this method to find out how many rows should be in the list.
	numberOfRows: function() {
		return this._rowData.length;
	},

	// The List calls this method once for every row.
	prepareRow: function(rowElement, rowIndex, templateElements) {
		// templateElements contains references to all elements that have an id in the template row.
		// Ex: set the value of an element with id="label".

		alert("The List row: "+this._rowData[rowIndex]);

		if (!this._rowData[rowIndex][9]) {
			alert("The List type: title");
			if (templateElements.label) {
				templateElements.label.innerText = this._rowData[rowIndex];
				templateElements.label.style.visibility = "visible";
				templateElements.listRowTemplate.style.backgroundColor = "rgba(0, 0, 0, 0.0)";
				templateElements.label.style.left = "6px";
				templateElements.label.style.right = "6px";
				templateElements.label.style.fontSize = "12px";
				templateElements.label.style.lineHeight = "24px";
				templateElements.label.style.fontFamily = "HelveticaNeue-Bold";
				templateElements.labelHSV.innerText = "";
				templateElements.labelRGB.innerText = "";
				templateElements.labelHEX.innerText = "";
				templateElements.swatchList.style.visibility = "hidden";
				templateElements.swatchListBox.style.visibility = "hidden";
				templateElements.imgDelete.style.visibility = "hidden";
			}
		} else {
			alert("The List type: swatch");
			if (templateElements.label) {
				templateElements.label.style.visibility = "hidden";
				templateElements.listRowTemplate.style.backgroundColor = "rgba(0.1, 0.1, 0.1, 0.0)";
			}
			if (templateElements.swatchList) {
				templateElements.swatchList.style.visibility = "visible";
				templateElements.swatchList.style.backgroundColor = "#"+this._rowData[rowIndex][8];
			}
			if (templateElements.swatchListBox) {
				templateElements.swatchListBox.style.visibility = "visible";
				templateElements.swatchListBox.style.backgroundColor = "#"+this._rowData[rowIndex][8];
			}
			if (templateElements.imgUse) {
				templateElements.imgUse.onmousedown = function(event) { fromLibrary(_this._rowData[rowIndex]) };
			}
			if (templateElements.imgDelete) {
				templateElements.imgDelete.style.visibility = "visible";
				templateElements.imgDelete.onclick = function(event) { editLibrary(_this._rowData[rowIndex][9]) };
			}

//	alert("Row data:\n"+this._rowData[rowIndex].join("\n"));

			// create values and clipboard elements
			var decimal = (prefAccuracy*2)+2;
			var tempHSV = parseH(this._rowData[rowIndex][2])+" "+parseSV(this._rowData[rowIndex][3])+" "+parseSV(this._rowData[rowIndex][4]);
			var clipHSV = (prefFormatHSV==3)?(this._rowData[rowIndex][2]).toFixed(decimal)+" "+(this._rowData[rowIndex][3]).toFixed(decimal)+" "+(this._rowData[rowIndex][4]).toFixed(decimal):tempHSV;

			var tempRGB = parseRGB(this._rowData[rowIndex][5])+" "+parseRGB(this._rowData[rowIndex][6])+" "+parseRGB(this._rowData[rowIndex][7]);
			var clipRGB = (prefFormatRGB==3)?(this._rowData[rowIndex][5]).toFixed(decimal)+" "+(this._rowData[rowIndex][6]).toFixed(decimal)+" "+(this._rowData[rowIndex][7]).toFixed(decimal):tempRGB;

			var tempHEX = _this._rowData[rowIndex][8];
			var clipHEX = tempHEX;

			if (prefShow == 0) {
				if (templateElements.label) {
					templateElements.label.innerText = "";
				}
				if (templateElements.labelHSV) {
					templateElements.labelHSV.innerText = tempHSV;
					templateElements.labelHSV.onclick = function(event) { copy(event,clipHSV) };
				}
				if (templateElements.labelRGB) {
					templateElements.labelRGB.innerText = tempRGB;
					templateElements.labelRGB.onclick = function(event) { copy(event,clipRGB) };
				}
				if (templateElements.labelHEX) {
					templateElements.labelHEX.innerText = "#"+tempHEX;
					templateElements.labelHEX.onclick = function(event) { copy(event,clipHEX) };
				}
			} else {
				if (templateElements.label) {
					templateElements.label.innerText = this._rowData[rowIndex][1];
				}
				if (templateElements.labelHSV) {
					templateElements.labelHSV.innerText = "";
				}
				if (templateElements.labelRGB) {
					if (prefShow == 1) {
						templateElements.labelRGB.innerText = tempHSV;
						templateElements.labelRGB.onclick = function(event) { copy(event,clipHSV) };
					} else if (prefShow == 2) {
						templateElements.labelRGB.innerText = tempRGB;
						templateElements.labelRGB.onclick = function(event) { copy(event,clipRGB) };
					}
				}
				if (templateElements.labelHEX) {
					templateElements.labelHEX.innerText = "#"+tempHEX;
					templateElements.labelHEX.onclick = function(event) { copy(event,clipHEX) };
				}
			}
		}

		_this = this;
//		rowElement.onclick = function(event) { alert(_this._rowData[2]); };

		// Assign a click event handler for the row.
//		rowElement.onclick = function(event) {
//			alert("Row "+rowIndex);
//		};
	}
};



// Conversion Processes

/*
 * Converts an RGB color value to HSV. Conversion formula adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and returns h, s, and v in the set [0, 1].
 * Udpate - modified to use floating point values instead, with 360 degrees for H.
 */
function RGBtoHSV(r, g, b){
	// load individual values, or pull from global preference
	r = r || pref[5];
	g = g || pref[6];
	b = b || pref[7];

	var max = Math.max(r, g, b), min = Math.min(r, g, b);
	var h, s, v = max;

	var d = max - min;
	s = max == 0 ? 0 : d / max;

	if(max == min){
		h = 0; // achromatic
	}else{
		switch(max){
			case r: h = (g - b) / d + (g < b ? 6 : 0); break;
			case g: h = (b - r) / d + 2; break;
			case b: h = (r - g) / d + 4; break;
		}
		h /= 6;
	}

//	s = s*100, h = (s <= 0.5) ? 0 : h*360, v = v*100;
	h = (s==0.0)?0:h*360;
	pref[2] = parseFloat(h);
	pref[3] = parseFloat(s);
	pref[4] = parseFloat(v);
	return [h, s, v];
}

/*
 * Converts an HSV color value to RGB. Conversion formula adapted from http://en.wikipedia.org/wiki/HSV_color_space
 * Assumes h, s, and v are contained in the set [0, 1] and returns r, g, and b in the set [0, 255].
 * Udpate - modified to use floating point values instead, with 360 degrees for H.
 */
function HSVtoRGB(h, s, v){
	// load individual values, or pull from global preference
	h = h || pref[2]/360;
	s = s || pref[3];
	v = v || pref[4];
	var r, g, b;

//alert("HSVtoRGB Source:\n"+h+"\n"+s+"\n"+v);

	var i = Math.floor(h * 6);
	var f = h * 6 - i;
	var p = v * (1 - s);
	var q = v * (1 - f * s);
	var t = v * (1 - (1 - f) * s);

	switch(i % 6){
		case 0: r = v, g = t, b = p; break;
		case 1: r = q, g = v, b = p; break;
		case 2: r = p, g = v, b = t; break;
		case 3: r = p, g = q, b = v; break;
		case 4: r = t, g = p, b = v; break;
		case 5: r = v, g = p, b = q; break;
	}

//alert("HSVtoRGB Output:\n"+r+"\n"+g+"\n"+b);

	pref[5] = parseFloat(r);
	pref[6] = parseFloat(g);
	pref[7] = parseFloat(b);
	return [r, g, b];
}

/*
 * Converts RGB value to HEX.
 * Expects floating point values, converts to 255 during processing.
 */
function RGBtoHEX(rgb) {
	rgb = rgb || [pref[5],pref[6],pref[7]];

	var hex = [];
	hex[0] = DECtoHEX(parseInt(rgb[0]*255));
	hex[1] = DECtoHEX(parseInt(rgb[1]*255));
	hex[2] = DECtoHEX(parseInt(rgb[2]*255));

	if (hex[0].length<2) hex[0] = "0"+hex[0];
	if (hex[1].length<2) hex[1] = "0"+hex[1];
	if (hex[2].length<2) hex[2] = "0"+hex[2];

	pref[8] = hex = (hex[0]+""+hex[1]+""+hex[2]).toUpperCase();
	return hex;
}

// required for RGBtoHEX
function DECtoHEX(dec) {
	return dec.toString(16);
}

/*
 * Converts HEX values to RGB.
 * Output is floating point values.
 */
function HEXtoRGB(hex) {
	hex = hex || pref[8];
	hex = hex.replace("#","");
	var r = HEXtoDEC(hex.substring(0,2))/255;
	var g = HEXtoDEC(hex.substring(2,4))/255;
	var b = HEXtoDEC(hex.substring(4,6))/255;

	pref[5] = parseFloat(r);
	pref[6] = parseFloat(g);
	pref[7] = parseFloat(b);
	return [r, g, b];
}

// required for HEXtoRGB
function HEXtoDEC(hex) {
	return parseInt(hex, 16);
}



// Parse values and convert to/from display formats

function parseH(value) {
//	if (value > 360) value = value % 360; // rollover 360 range
	switch(prefFormatHSV){
		case 0: value = parseInt(value); break;
		case 1: value = parseInt((value/360)*255); break;
		case 2: value = parseInt((value/360)*100); break;
		case 3: value = (value/360).toFixed(2); break;
	}
	return value;
}

function fromH(value) {
	switch(prefFormatHSV){
		case 0: value = parseInt(value); break;
		case 1: value = parseFloat((value/255)*360); break;
		case 2: value = parseFloat((value/100)*360); break;
		case 3: value = parseFloat(value)*360; break;
	}
//	if (value > 360) value = value % 360; // rollover 360 range
	return value;
}

function parseSV(value) {
//	if (value > 1) value = 1; // limited 0-1 range
	switch(prefFormatHSV){
		case 0: value = parseInt(value*100); break;
		case 1: value = parseInt(value*255); break;
		case 2: value = parseInt(value*100); break;
		case 3: value = value.toFixed(2); break;
	}
	return value;
}

function fromSV(value) {
	switch(prefFormatHSV){
		case 0: value = parseFloat(value/100); break;
		case 1: value = parseFloat(value/255); break;
		case 2: value = parseFloat(value/100); break;
		case 3: value = parseFloat(value); break;
	}
//	if (value > 1) value = 1; // limited 0-1 range
	return value;
}

function parseRGB(value) {
//	if (value > 1) value = 1; // limited 0-1 range
	switch(prefFormatRGB){
		case 0: value = parseInt(value*255); break;
		case 1: value = parseInt(value*100); break;
		case 2: value = value.toFixed(2); break;
	}
	return value;
}

function fromRGB(value) {
	switch(prefFormatRGB){
		case 0: value = parseFloat(value/255); break;
		case 1: value = parseFloat(value/100); break;
		case 2: value = parseFloat(value); break;
	}
//	if (value > 1) value = 1; // limited 0-1 range
	return value;
}



// CurrentView animations

function showMain(event) {
	document.getElementById("stack").object.setCurrentView("main", false, true);
}

function showSuccess(event) {
	document.getElementById("stack").object.setCurrentView("success", true, true);
}

function showFail(event) {
	document.getElementById("stack").object.setCurrentView("fail", true, true);
}

function showTruncated(event) {
	document.getElementById("stack").object.setCurrentView("truncated", true, true);
}

function showCreate(event) {
	document.getElementById("stack").object.setCurrentView("create", true, true);
}

function showUpdate(event) {
	document.getElementById("stack").object.setCurrentView("update", true, true);
}

function showValues(event) {
	document.getElementById("stack2").object.setCurrentView("values", true, true);
}

function showNames(event) {
	document.getElementById("stack2").object.setCurrentView("names", false, true);
}

function showNames2(event) {
	document.getElementById("stack2").object.setCurrentView("names", true, true);
}

function showAlert(event) {
	document.getElementById("stack2").object.setCurrentView("alert", false, true);
}

// Element animations

function buttonOver(event) {
	var itemToFadeIn = event.target;
	var fadeHandler = function(a, c, s, f){ itemToFadeIn.style.opacity = c; };
	new AppleAnimator(200, 5, 0.30, 0.90, fadeHandler).start();
}

function buttonOut(event) {
	var itemToFadeIn = event.target;
	var fadeHandler = function(a, c, s, f){ itemToFadeIn.style.opacity = c; };
	new AppleAnimator(400, 10, 0.90, 0.30, fadeHandler).start();
}

function backgroundOver(event) {
	event.target.style.backgroundColor = "rgb(32,32,32)";
}

function backgroundOut(event) {
	event.target.style.backgroundColor = "rgb(26,26,26)";
}

function copyFlash(event) {
	var itemToFadeIn = event.target;
	var fadeHandler = function(a, c, s, f){ itemToFadeIn.style.opacity = c; };
	new AppleAnimator(600, 15, 0.30, 1, fadeHandler).start();
}

function copyFlashDim(event) {
	var itemToFadeIn = event.target;
	var fadeHandler = function(a, c, s, f){ itemToFadeIn.style.opacity = c; };
	new AppleAnimator(600, 15, 0.30, 0.6, fadeHandler).start();
}


// Get Key Value

function getKeyValue(plist, key) {
	var infoPlist = new XMLHttpRequest();
	infoPlist.open("GET", plist, false);
	infoPlist.send(null);
	infoPlist = infoPlist.responseText.replace(/(<([^>]+)>)/ig,"").replace(/\t/ig,"").split("\n");
	for (var i=0; i<infoPlist.length; i++)
		if (infoPlist[i] == key) return infoPlist[i+1];
	return false;
}

// Auto Update

function versionCheck(event) {
	var request = new XMLHttpRequest();
	var address = "http://iaian7.com/files/dashboard/chroma/version.php?RandomKey=" + Date.parse(new Date());
	request.onload = function() { versionCheckEnd(request); };
	request.open("GET", address);
//	request.setRequestHeader("Cache-Control", "no-cache");
	request.send(null);
}

function versionCheckEnd(request){
	if (request.status == 200) {
		var versions = request.responseText.split("\n");
		var bundleVersion = getKeyValue("Info.plist", "CFBundleVersion");
		var websiteVersion = versions[0];
		alert("bundleVersion: "+bundleVersion);
		alert("websiteVersion: "+websiteVersion);

		if (websiteVersion > bundleVersion) {
			document.getElementById("newVersion").innerHTML = "version "+versions[0]+"<br/>"+versions[1];
			return showUpdate();
		} else {
//			alert("you have an up to date version");
		}
	} else {
//		alert("there's been an error fetching HTTP data");
	}
}

// Download File

function versionDownload() {
	widget.openURL("http://iaian7.com/files/dashboard/chroma/Chroma.zip");
	showMain();
}

// Skip Version

function versionSkip() {
	loadPrefs();
//	processLibrary();
}

// Visit the website

function iaian7(event)
{
	widget.openURL("http://iaian7.com/dashboard/chroma");
}