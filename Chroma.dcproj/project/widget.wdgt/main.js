/*
 This file was generated by Dashcode.
 You may edit this file to customize your widget or web page
 according to the license.txt file included in the project.
 */

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{
	dashcode.setupParts();
	versionCheck();
	loadPrefs();
}

//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
	// Stop any timers to prevent CPU usage
	// Remove any preferences as needed
	// widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
	erasePrefs();
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
	// Stop any timers to prevent CPU usage
	updateScroll();
	savePrefs();
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
	// Restart any timers that were stopped on hide
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
	// Retrieve any preference values that you need to be synchronized here
	// Use this for an instance key's value:
	// instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
	//
	// Or this for global key's value:
	// globalPreferenceValue = widget.preferenceForKey(null, "your-key");
}

//
// Function: showBack(event)
// Called when the info button is clicked to show the back of the widget
//
// event: onClick event from the info button
//
function showBack(event)
{
	updateScroll();
	var front = document.getElementById("front");
	var back = document.getElementById("back");

	if (window.widget) {
		widget.prepareForTransition("ToBack");
	}

	front.style.display = "none";
	back.style.display = "block";

	if (window.widget) {
		setTimeout('widget.performTransition();', 0);
	}
}

//
// Function: showFront(event)
// Called when the done button is clicked from the back of the widget
//
// event: onClick event from the done button
//
function showFront(event)
{
	var front = document.getElementById("front");
	var back = document.getElementById("back");

	if (window.widget) {
		widget.prepareForTransition("ToFront");
		updatePrefs();
		checkDir();
//		getLibrary();
	}

	front.style.display="block";
	back.style.display="none";

	if (window.widget) {
		setTimeout('widget.performTransition();', 0);
	}
}

if (window.widget) {
	widget.onremove = remove;
	widget.onhide = hide;
	widget.onshow = show;
	widget.onsync = sync;
}

// Begin app-specific functions

var wid = widget.identifier;
var pref = [];
pref[2] = loadPref(wid+"H",30);
pref[3] = loadPref(wid+"S",90);
pref[4] = loadPref(wid+"V",100);
pref[5] = loadPref(wid+"R",255);
pref[6] = loadPref(wid+"G",140);
pref[7] = loadPref(wid+"B",25);
pref[8] = loadPref(wid+"HEX","FF8C19");
prefSort = loadPref(wid+"sort",0);
prefShow = loadPref(wid+"show",0);
prefLocation = loadPref(wid+"location","~/Library/Preferences/");
prefGroup = loadPref(wid+"group","group");
prefName = loadPref(wid+"name","name");
prefScroll = loadPref(wid+"scroll",0);

var busy = false;
var add = false;
var del = false;
var libArray = [["grayscale", "black", 0, 0, 0, 0, 0, 0, "000000", 2], ["grayscale", "gray", 0, 0, 50, 128, 128, 128, "656565", 3], ["grayscale", "white", 0, 0, 100, 255, 255, 255, "FFFFFF", 4], ["group", "orange", 30, 90, 100, 255, 140, 25, "FF8C19", 1]];

//var libString = "0,0,0,0,0,0,000000,grayscale,black,2\n0,0,50,128,128,128,656565,grayscale,gray,3\n0,0,100,255,255,255,FFFFFF,grayscale,white,4\n30,90,100,255,140,25,FF8C19,group,orange,1";
var libString = "";

// Preference Saving

function loadPref(key,value) {
	var string = widget.preferenceForKey(key);
	if (string != null) {
		return string;
	} else {
		widget.setPreferenceForKey(value,key);
		return value;
	}
}

function loadPrefs() {
	document.getElementById("sort").object.setSelectedIndex(prefSort);
	document.getElementById("show").object.setSelectedIndex(prefShow);
	document.getElementById("location").value = prefLocation;
	updateAll("ALL");
	checkDir();
}

function savePref(key,value) {
	if (window.widget) {
		widget.setPreferenceForKey(value,wid+key);
	}
}

function updatePrefs() {
	if (window.widget) {
		widget.setPreferenceForKey(pref[2],wid+"H");
		widget.setPreferenceForKey(pref[3],wid+"S");
		widget.setPreferenceForKey(pref[4],wid+"V");
		widget.setPreferenceForKey(pref[5],wid+"R");
		widget.setPreferenceForKey(pref[6],wid+"G");
		widget.setPreferenceForKey(pref[7],wid+"B");
		widget.setPreferenceForKey(pref[8],wid+"X");
		widget.setPreferenceForKey(prefSort,wid+"sort");
		widget.setPreferenceForKey(prefShow,wid+"show");
		widget.setPreferenceForKey(prefLocation,wid+"location");
		widget.setPreferenceForKey(prefGroup,wid+"group");
		widget.setPreferenceForKey(prefName,wid+"name");
		widget.setPreferenceForKey(prefScroll,wid+"scroll");
	}
}

function erasePrefs() {
	if (window.widget) {
		widget.setPreferenceForKey(null,wid+"H");
		widget.setPreferenceForKey(null,wid+"S");
		widget.setPreferenceForKey(null,wid+"V");
		widget.setPreferenceForKey(null,wid+"R");
		widget.setPreferenceForKey(null,wid+"G");
		widget.setPreferenceForKey(null,wid+"B");
		widget.setPreferenceForKey(null,wid+"X");
		widget.setPreferenceForKey(null,wid+"sort");
		widget.setPreferenceForKey(null,wid+"show");
		widget.setPreferenceForKey(null,wid+"location");
		widget.setPreferenceForKey(null,wid+"group");
		widget.setPreferenceForKey(null,wid+"name");
		widget.setPreferenceForKey(null,wid+"scroll");
	}
}

// Basic Functions

function updateAll(event) {
	if (event != "HSV") {
		document.getElementById("H").value = parseInt(pref[2]);
		document.getElementById("S").value = parseInt(pref[3]);
		document.getElementById("V").value = parseInt(pref[4]);
	}
	if (event != "RGB") {
		document.getElementById("R").value = parseInt(pref[5]);
		document.getElementById("G").value = parseInt(pref[6]);
		document.getElementById("B").value = parseInt(pref[7]);
	}
	if (event != "HEX") {
		document.getElementById("X").value = "#"+pref[8];
	}
	if (document.getElementById("swatch")) document.getElementById("swatch").style.backgroundColor = "#"+pref[8];
	if (document.getElementById("swatchSave")) document.getElementById("swatchSave").style.backgroundColor = "#"+pref[8];

	document.getElementById("groupTitle").value = prefGroup;
	document.getElementById("nameTitle").value = prefName;
}

function updateSort(event) {
	prefSort = document.getElementById("sort").object.getSelectedIndex();
}

function updateShow(event) {
	prefShow = document.getElementById("show").object.getSelectedIndex();
}

function updateLocation(event) {
	prefLocation = document.getElementById("location").value;
}

function updateGroup(event) {
	prefGroup = document.getElementById("groupTitle").value;
}

function updateName(event) {
	prefName = document.getElementById("nameTitle").value;
}

function updateScroll() {
	prefScroll = document.getElementById("scrollArea").object.content.scrollTop;
	widget.setPreferenceForKey(prefScroll,wid+"scroll");
//	alert("updateScroll = "+prefScroll);
}

function updateScrollArea() {
	var scrollArea = document.getElementById("scrollArea").object
	scrollArea.refresh();
	scrollArea.verticalScrollTo(prefScroll);
}

function updateInput(event) {
	var data = parseFloat(event.target.value);
	var limit = 255;
	var increment = 8;
	var prefId = 8;

	switch (event.target.id) {
	case "H":
		prefId = 2;
		limit = 360;
		increment = 10;
		break;
	case "S":
		prefId = 3;
		limit = 100;
		increment = 10;
		break;
	case "V":
		prefId = 4;
		limit = 100;
		increment = 10;
		break;
	case "R":
		prefId = 5;
		break;
	case "G":
		prefId = 6;
		break;
	case "B":
		prefId = 7;
		break;
	default:
		increment = false;
		data = event.target.value.match(/([0-9a-f]{6})/i);
//		data = event.target.value.match(/^#?([0-9a-f]{6})$/i);
		if (data && event.keyCode>40) {
			pref[8] = data[1].replace("#","").toUpperCase();	// removes hashtag before saving to the preferences
			if (!data[0].match("#")) event.target.value = "#"+pref[8];
			HEXtoRGB();
			RGBtoHSV();
			return updateAll("HEX");
		} else {
			return false;
		}
	}

	if (event.keyCode == 38 && increment) {
		if (event.shiftKey == true) {
			data += increment;
		} else {
			data += 1;
		}
		event.target.value = data;
		selectIt(event.target);
	} else if (event.keyCode == 40 && increment) {
		if (event.shiftKey == true) {
			data -= increment;
		} else {
			data -= 1;
		}
		event.target.value = data;
		selectIt(event.target);
	}

	if (data>=0 && ((data % 1) == 0)) {
		if (data>limit) {
//			alert("met limit");
			data = limit;
			event.target.value = data;
		}
		pref[prefId] = data;
	} else {
//		alert("invalid");
		event.target.value = parseInt(pref[prefId]);
	}

	if (increment == 10) {
		HSVtoRGB();
		RGBtoHEX();
		return updateAll("HSV");
	} else {
		RGBtoHSV();
		RGBtoHEX();
		return updateAll("RGB");
	}
}



// Library checks

function checkDir(event) {
	widget.system(prefLocation, checkDirEnd);
}

function checkDirEnd(event) {
	if (event.status == 126) {
		alert("directory exists");
		return getLibrary();
	} else {
		alert("directory does NOT exist: "+event.status);
		document.getElementById("createText").innerText = "specified directory location\ndoes not exist";
		return showCreate();
	}
}



// Library management

function addLibrary(event) {
	updateScroll();
	if (prefGroup.search(/[a-z]/i)<0 || prefName.search(/[a-z]/i)<0) return showAlert();
	add = [prefGroup,prefName,pref[2],pref[3],pref[4],pref[5],pref[6],pref[7],pref[8],new Date().getTime()];
	getLibrary();
	showValues();
}

function editLibrary(event) {
	updateScroll();
	del = event;
	getLibrary();
}

function getLibrary(event) {
	libString = "";
	var myCommand = widget.system("cat "+prefLocation+"chromaLibrary.txt", processLibrary);
	myCommand.onreadoutput = processLibraryConcat;
}

function processLibraryConcat(event) {
//	alert("concat = "+event.length);
	libString = libString+event;
}



// Library processing

function processLibrary(event) {
	if (busy == "processing") {
		return showFail();
	} else if (busy == "newVersion") {
		return false;
	} else if (libString.length == 4096) {
		return showTruncated();
	} else if (event.status>0) {
		document.getElementById("createText").innerText = "chromaLibrary.txt\ndoes not exist";
		return showCreate();
	} else {
		document.getElementById("createText").innerText = "library processing\nin progress";
	}

//	alert("1 = libArray before processing: "+libArray[libArray.length-1]);
	busy = "processing";
	libArray = libString.split("\n");
//	for(var i in libArray) {	// THIS SOMEHOW CORRUPTS DASHCODE'S JAVASCRIPT ENGINE???
	for(var i=0; i<libArray.length; i++) {
		libArray[i] = libArray[i].replace(",#",",").split(",");	// replace function strips hash tag from hex values of older librarys
	}

	libArray = arrayClean(libArray);
//	alert("2 = libArray after clean: (last element only) "+libArray[libArray.length-1]);

	if (add) {
		if (!libArray[0][1]) {
			libArray = [""];
			libArray[0] = add;
		} else {
			libArray.push(add);
		}
		add = false;
	}

	if (del) {
		del = arrayMatch(libArray,9,del);
		if (del) libArray.splice(del,1);
		del = false;
	}

	libArray = arrayGroups(libArray);
//	alert("3 = libArray after groups: "+libArray[libArray.length-1]);

	if (libArray[1]) {
		switch (prefSort) {
		case 1:
			libArray.sort(sortHue);
			break;
		case 2:
			libArray.sort(sortSaturation);
			break;
		case 3:
			libArray.sort(sortValue);
			break;
		case 4:
			libArray.sort(sortDate);
			break;
		default:
			libArray.sort(sortName);
		}
	}

//	alert("4 = libArray after processing: "+libArray[libArray.length-1]);
	if (busy != "newVersion") showMain();
	listDataSource._rowData = libArray;
	list.object.reloadData();
//	document.getElementById("scrollArea").object.refresh();
	updateScrollArea();
	busy = false;
	setLibrary();
}

function arrayMatch(arr,ind,str) {
//	for(var i in arr) {
	for(var i=0; i<arr.length; i++) {
		if (arr[i][ind] == str) return i;
	}
	return false;
}

function arraySearch(arr,str) {
//	for(var i in arr) {
	for(var i=0; i<arr.length; i++) {
//		alert("array index == "+i);
//		alert("array element == "+arr[i]);
//		if (arr[i] == str) return i;	// THIS CAN CAUSE AN ENDLESS LOOP OR CORRUPTION IN ANOTHER SECTION OF CODE!!!
		if (arr[i] == str) return true;
	}
	return false;
}

function arrayClean(arr) {
	var arr2 = [];
//	for(var i in arr) {
	for(var i=0; i<arr.length; i++) {
		if (arr[i][9]) {
			if (isFinite(arr[i][0])) {
				arr[i] = [arr[i][7],arr[i][8],arr[i][0],arr[i][1],arr[i][2],arr[i][3],arr[i][4],arr[i][5],arr[i][6],arr[i][9]];
				arr2.push(arr[i]);
			} else {
				arr2.push(arr[i]);
			}
		}
	}
	return arr2;
}

function arrayGroups(arr) {
	var arrGroup = [];
//	for(var i in arr) {
	for(var i=0; i<arr.length; i++) {
		if (!arraySearch(arrGroup,arr[i][0])) {
			arrGroup.push(arr[i][0]);
			arr.push([arr[i][0]]);
		}
	}
	return arr;
}

function arrayReformat(arr) {
	if (isFinite(arr[0])) arr = [arr[7],arr[8],arr[0],arr[1],arr[2],arr[3],arr[4],arr[5],arr[6],arr[9]];
	return arr;
}

function sortName(a, b) {
	var x = a[0].toLowerCase();
	var y = b[0].toLowerCase();
	if (x==y && !a[1]) { return -1; } else if (x==y && !b[1]) { return 1; }
	if (x==y) x = a[1].toLowerCase(), y = b[1].toLowerCase();
	return (x < y) ? -1 : ((x > y) ? 1 : 0);
}

function sortHue(a, b){
	var x = a[0].toLowerCase();
	var y = b[0].toLowerCase();
	if (x==y && !a[1]) { return -1; } else if (x==y && !b[1]) { return 1; }
	return (x < y) ? 1 : ((x > y) ? -1 : a[2] - b[2]);
}

function sortSaturation(a, b){
	var x = a[0].toLowerCase();
	var y = b[0].toLowerCase();
	if (x==y && !a[1]) { return -1; } else if (x==y && !b[1]) { return 1; }
	return (x < y) ? 1 : ((x > y) ? -1 : a[3] - b[3]);
}

function sortValue(a, b){
	var x = a[0].toLowerCase();
	var y = b[0].toLowerCase();
	if (x==y && !a[1]) { return -1; } else if (x==y && !b[1]) { return 1; }
	return (x < y) ? 1 : ((x > y) ? -1 : a[4] - b[4]);
}

function sortDate(a, b){
	if (x==y && !a[1]) { return -1; } else if (x==y && !b[1]) { return 1; }
	return a[9] - b[9];
}

function setLibrary(event) {
	if (busy == "setProcessing") return showFail();
	busy = "setProcessing";
//	alert("5 = libArray before writing file: "+libArray[libArray.length-1]);
	var myCommand = widget.system("cat > "+prefLocation+"chromaLibrary.txt", setLibraryEnd);
//	for(var i in libArray) {
	for(var i=0; i<libArray.length; i++) {
		if (i == 0) {
			myCommand.write(libArray[i].join(","));
		} else {
			myCommand.write("\n"+libArray[i].join(","));
		}
	}
	myCommand.close();
}

function setLibraryEnd(event) {
//	alert("setLibraryEnd = "+event);
	busy = false;
}

function fromLibrary(event) {
	prefGroup = event[0];
	prefName = event[1];
	pref[2] = event[2];
	pref[3] = event[3];
	pref[4] = event[4];
	pref[5] = event[5];
	pref[6] = event[6];
	pref[7] = event[7];
	pref[8] = event[8];
	updateAll("ALL");
}

function createLibrary(event) {
//	alert("createLibrary");
	setLibrary();
	getLibrary();
	showMain();
}

// Clipboard

function copy(event,value){
	copyFlash(event);
	widget.system("/usr/bin/osascript -e 'set the clipboard to \"" + value + "\"'", null);
}



// Key listeners

function selectIt(event) {
	if(event.target){
		event = event.target;
	}
//	event.focus();
	event.select();
}



//// LIST BOX

var _this = [];

// This object implements the dataSource methods for the list.
var listDataSource = {

	// Sample data for the content of the list.
	// Your application may also fetch this data remotely via XMLHttpRequest.
	_rowData: [["empty library"]],

	// The List calls this method to find out how many rows should be in the list.
	numberOfRows: function() {
		return this._rowData.length;
	},

	// The List calls this method once for every row.
	prepareRow: function(rowElement, rowIndex, templateElements) {
		// templateElements contains references to all elements that have an id in the template row.
		// Ex: set the value of an element with id="label".
		if (!this._rowData[rowIndex][9]) {
			if (templateElements.label) {
				templateElements.label.innerText = this._rowData[rowIndex];
				templateElements.label.style.opacity = 1.0;
				templateElements.listRowTemplate.style.backgroundColor = "rgba(0, 0, 0, 0.0)";
				templateElements.label.style.left = "6px";
				templateElements.label.style.right = "6px";
				templateElements.label.style.fontSize = "12px";
				templateElements.label.style.lineHeight = "24px";
				templateElements.label.style.fontFamily = "HelveticaNeue-Bold";
				templateElements.labelHSV.innerText = "";
				templateElements.labelRGB.innerText = "";
				templateElements.labelHEX.innerText = "";
				templateElements.swatchList.style.opacity = 0;
//				templateElements.button.style.opacity = 0;
				templateElements.imgDelete.style.visibility = "hidden";
			}
		} else {
			if (templateElements.swatchList) {
				templateElements.swatchList.style.backgroundColor = "#"+this._rowData[rowIndex][8];
			}
			if (templateElements.imgUse) {
				templateElements.imgUse.onclick = function(event) { fromLibrary(_this._rowData[rowIndex]) };
			}
//			if (templateElements.button) {
//				templateElements.button.style.backgroundColor = "#"+this._rowData[rowIndex][8];
//				templateElements.button.style.imageTopColor = "#"+this._rowData[rowIndex][8];
//				templateElements.button.style.imageBottomColor = "#"+this._rowData[rowIndex][8];
//				templateElements.button.onclick = function(event) { fromLibrary(_this._rowData[rowIndex]) };
//			}
			if (templateElements.imgDelete) {
				templateElements.imgDelete.onclick = function(event) { editLibrary(_this._rowData[rowIndex][9]) };
			}

			var tempHSV = parseInt(this._rowData[rowIndex][2])+" "+parseInt(this._rowData[rowIndex][3])+" "+parseInt(this._rowData[rowIndex][4]);
			var tempRGB = parseInt(this._rowData[rowIndex][5])+" "+parseInt(this._rowData[rowIndex][6])+" "+parseInt(this._rowData[rowIndex][7]);
			var tempHEX = _this._rowData[rowIndex][8];

			if (prefShow == 0) {
				if (templateElements.labelHSV) {
					templateElements.labelHSV.innerText = tempHSV;
					templateElements.labelHSV.onclick = function(event) { copy(event,tempHSV) };
				}
				if (templateElements.labelRGB) {
					templateElements.labelRGB.innerText = tempRGB;
					templateElements.labelRGB.onclick = function(event) { copy(event,tempRGB) };
				}
				if (templateElements.labelHEX) {
					templateElements.labelHEX.innerText = "#"+tempHEX;
					templateElements.labelHEX.onclick = function(event) { copy(event,tempHEX) };
				}
			} else {
				if (templateElements.label) {
					templateElements.label.innerText = this._rowData[rowIndex][1];
				}
				if (templateElements.labelHSV) {
					templateElements.labelHSV.innerText = "";
				}
				if (templateElements.labelRGB && templateElements.labelHEX) {
					if (prefShow == 1) {
						templateElements.labelRGB.innerText = tempHSV;
						templateElements.labelRGB.onclick = function(event) { copy(event,tempHSV) };
						templateElements.labelHEX.innerText = "#"+tempHEX;
						templateElements.labelHEX.onclick = function(event) { copy(event,tempHEX) };
					} else if (prefShow == 2) {
						templateElements.labelRGB.innerText = tempRGB;
						templateElements.labelRGB.onclick = function(event) { copy(event,tempRGB) };
						templateElements.labelHEX.innerText = "#"+tempHEX;
						templateElements.labelHEX.onclick = function(event) { copy(event,tempHEX) };
					}
				}
			}
		}

		_this = this;
//		rowElement.onclick = function(event) { alert(_this._rowData[2]); };

		// Assign a click event handler for the row.
//		rowElement.onclick = function(event) {
//			alert("Row "+rowIndex);
//		};
	}
};



// Conversion Processes

/*
 * Converts an RGB color value to HSV. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and v in the set [0, 1].
 * Changed to return h, s, and v in [0, 360] and [0, 100].
 */
function RGBtoHSV(r, g, b){
	r = r || pref[5];
	g = g || pref[6];
	b = b || pref[7];

	r = r/255, g = g/255, b = b/255;
	var max = Math.max(r, g, b), min = Math.min(r, g, b);
	var h, s, v = max;

	var d = max - min;
	s = max == 0 ? 0 : d / max;

	if(max == min){
		h = 0; // achromatic
	}else{
		switch(max){
			case r: h = (g - b) / d + (g < b ? 6 : 0); break;
			case g: h = (b - r) / d + 2; break;
			case b: h = (r - g) / d + 4; break;
		}
		h /= 6;
	}

//	h = h*360, s = s*100, v = v*100;
	s = s*100, h = (s <= 0.5) ? 0 : h*360, v = v*100;
	pref[2] = h;
	pref[3] = s;
	pref[4] = v;
	return [h, s, v];
}

/*
 * Converts an HSV color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes h, s, and v are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 */
function HSVtoRGB(h, s, v){
	h = h || pref[2]/360;
	s = s || pref[3]/100;
	v = v || pref[4]/100;
	var r, g, b;

	var i = Math.floor(h * 6);
	var f = h * 6 - i;
	var p = v * (1 - s);
	var q = v * (1 - f * s);
	var t = v * (1 - (1 - f) * s);

	switch(i % 6){
		case 0: r = v, g = t, b = p; break;
		case 1: r = q, g = v, b = p; break;
		case 2: r = p, g = v, b = t; break;
		case 3: r = p, g = q, b = v; break;
		case 4: r = t, g = p, b = v; break;
		case 5: r = v, g = p, b = q; break;
	}

	r = r*255, g = g*255, b = b*255;
	pref[5] = r;
	pref[6] = g;
	pref[7] = b;
	return [r, g, b];
}

function RGBtoHEX(rgb) {
	rgb = rgb || [pref[5],pref[6],pref[7]];
	var hex = [];
	hex[0] = DECtoHEX(parseInt(rgb[0]));
	hex[1] = DECtoHEX(parseInt(rgb[1]));
	hex[2] = DECtoHEX(parseInt(rgb[2]));

	if (hex[0].length<2) hex[0] = "0"+hex[0];
	if (hex[1].length<2) hex[1] = "0"+hex[1];
	if (hex[2].length<2) hex[2] = "0"+hex[2];

	pref[8] = hex = (hex[0]+""+hex[1]+""+hex[2]).toUpperCase();
	return hex;
}

function DECtoHEX(dec) {
	return dec.toString(16);
}

function HEXtoRGB(hex) {
	hex = hex || pref[8];
	hex = hex.replace("#","");
	var r = HEXtoDEC(hex.substring(0,2));
	var g = HEXtoDEC(hex.substring(2,4));
	var b = HEXtoDEC(hex.substring(4,6));

	pref[5] = r;
	pref[6] = g;
	pref[7] = b;
	return [r, g, b];
}

function HEXtoDEC(hex) {
	return parseInt(hex, 16);
}



// CurrentView animations

function showMain(event) {
	document.getElementById("stack").object.setCurrentView("main", false, true);
}

function showSuccess(event) {
	document.getElementById("stack").object.setCurrentView("success", true, true);
}

function showFail(event) {
	document.getElementById("stack").object.setCurrentView("fail", true, true);
}

function showTruncated(event) {
	document.getElementById("stack").object.setCurrentView("truncated", true, true);
}

function showCreate(event) {
	document.getElementById("stack").object.setCurrentView("create", true, true);
}

function showUpdate(event) {
	document.getElementById("stack").object.setCurrentView("update", true, true);
}

function showValues(event) {
	document.getElementById("stack2").object.setCurrentView("values", true, true);
}

function showNames(event) {
	document.getElementById("stack2").object.setCurrentView("names", false, true);
}

function showNames2(event) {
	document.getElementById("stack2").object.setCurrentView("names", true, true);
}

function showAlert(event) {
	document.getElementById("stack2").object.setCurrentView("alert", false, true);
}

// Element animations

function buttonOver(event) {
	var itemToFadeIn = event.target;
	var fadeHandler = function(a, c, s, f){ itemToFadeIn.style.opacity = c; };
	new AppleAnimator(200, 5, 0.30, 0.70, fadeHandler).start();
}

function buttonOut(event) {
	var itemToFadeIn = event.target;
	var fadeHandler = function(a, c, s, f){ itemToFadeIn.style.opacity = c; };
	new AppleAnimator(400, 10, 0.70, 0.30, fadeHandler).start();
}

function copyFlash(event) {
	var itemToFadeIn = event.target;
	var fadeHandler = function(a, c, s, f){ itemToFadeIn.style.opacity = c; };
	new AppleAnimator(600, 15, 0.30, 1, fadeHandler).start();
}

function libraryToggle(event) {
	var libraryItem = document.getElementById("library");
	var libraryToggleItem = document.getElementById("imgToggle");
	var stackItem = document.getElementById("stack2");
	var bottomPosition0 = 72;	// actually 70, not 60, some equations may require (c-10) or (c+10)
	var bottomPosition1 = 10;
	var originalBottom = parseInt(document.defaultView.getComputedStyle(libraryItem, null).getPropertyValue("bottom"));
	alert('originalBottom == '+originalBottom);
	var moveHandler = function(a, c, s, f){ libraryItem.style.bottom = c+"px"; libraryToggleItem.style.top = (-10+((c-10)/6))+"px"; stackItem.style.height = (60*((c-10)/60))+"px"; alert('c == '+c); };

	if (originalBottom <= 10) {
		var animator = new AppleAnimator(300, 7, originalBottom, bottomPosition0, moveHandler);
	} else {
		var animator = new AppleAnimator(300, 7, originalBottom, bottomPosition1, moveHandler);
	}
	animator.oncomplete = function() {document.getElementById("scrollArea").object.refresh()};
	animator.start();
}



// Get Key Value

function getKeyValue(plist, key) {
	var infoPlist = new XMLHttpRequest();
	infoPlist.open("GET", plist, false);
	infoPlist.send(null);
	infoPlist = infoPlist.responseText.replace(/(<([^>]+)>)/ig,"").replace(/\t/ig,"").split("\n");
	for (var i=0; i<infoPlist.length; i++)
		if (infoPlist[i] == key) return infoPlist[i+1];
	return false;
}

// Auto Update

function versionCheck(event) {
	var request = new XMLHttpRequest();
	var address = "http://iaian7.com/files/dashboard/chroma/version.php?RandomKey=" + Date.parse(new Date());
	request.onload = function() { versionCheckEnd(request); };
	request.open("GET", address);
//	request.setRequestHeader("Cache-Control", "no-cache");
	request.send(null);
}

function versionCheckEnd(request){
	if (request.status == 200) {
		var versions = request.responseText.split("\n");
		var bundleVersion = getKeyValue("Info.plist", "CFBundleVersion");
		var websiteVersion = versions[0];
		alert("bundleVersion: "+bundleVersion);
		alert("websiteVersion: "+websiteVersion);

		if (websiteVersion != bundleVersion) {
			document.getElementById("newVersion").innerHTML = "version "+versions[0]+"<br/>"+versions[1];
			busy = "newVersion";
			return showUpdate();
		} else {
			alert("you have an up to date version");
		}
	} else {
		alert("there's been an error fetching HTTP data");
	}
}

// Download File

function versionDownload() {
	widget.openURL("http://iaian7.com/files/dashboard/chroma/Chroma.zip");
	showMain();
}

// Skip Version

function versionSkip() {
	busy = false;
	loadPrefs();
}

// Visit the website

function iaian7(event)
{
	widget.openURL("http://iaian7.com/dashboard/chroma");
}