/* 
 This file was generated by Dashcode.  
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{
	dashcode.setupParts();
	loadPrefs();
	versionCheck();
}

//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
	// Stop any timers to prevent CPU usage
	// Remove any preferences as needed
	// widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
	erasePrefs();
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
	// Stop any timers to prevent CPU usage
	savePrefs();
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
	// Restart any timers that were stopped on hide
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
	// Retrieve any preference values that you need to be synchronized here
	// Use this for an instance key's value:
	// instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
	//
	// Or this for global key's value:
	// globalPreferenceValue = widget.preferenceForKey(null, "your-key");
}

//
// Function: showBack(event)
// Called when the info button is clicked to show the back of the widget
//
// event: onClick event from the info button
//
function showBack(event)
{
	var front = document.getElementById("front");
	var back = document.getElementById("back");

	if (window.widget) {
		widget.prepareForTransition("ToBack");
	}

	front.style.display = "none";
	back.style.display = "block";

	if (window.widget) {
		setTimeout('widget.performTransition();', 0);
	}
}

//
// Function: showFront(event)
// Called when the done button is clicked from the back of the widget
//
// event: onClick event from the done button
//
function showFront(event)
{
	var front = document.getElementById("front");
	var back = document.getElementById("back");

	if (window.widget) {
		widget.prepareForTransition("ToFront");
		updatePrefs();
		getLibrary();
	}

	front.style.display="block";
	back.style.display="none";

	if (window.widget) {
		setTimeout('widget.performTransition();', 0);
	}
}

if (window.widget) {
	widget.onremove = remove;
	widget.onhide = hide;
	widget.onshow = show;
	widget.onsync = sync;
}

// Begin app-specific functions

var wid = widget.identifier;
var pref = [];
pref[0] = loadPref(wid+"H",30);
pref[1] = loadPref(wid+"S",90);
pref[2] = loadPref(wid+"V",100);
pref[3] = loadPref(wid+"R",255);
pref[4] = loadPref(wid+"G",140);
pref[5] = loadPref(wid+"B",25);
pref[6] = loadPref(wid+"HEX","#FF8C19");
prefSort = loadPref(wid+"sort",0);
prefLocation = loadPref(wid+"location","~/Dropbox/Sync/");
prefGroup = loadPref(wid+"group","group");
prefName = loadPref(wid+"name","name");

var busy = false;
var add = false;
var del = false;
var libArray = [[0, 0, 0, 0, 0, 0, "#000000", "grayscale", "black", 2], [0, 0, 50, 128, 128, 128, "#656565", "grayscale", "gray", 3], [0, 0, 100, 255, 255, 255, "#FFFFFF", "grayscale", "white", 4], [30, 90, 100, 255, 140, 25, "#FF8C19", "group", "orange", 1]];

var libString = "0,0,0,0,0,0,#000000,grayscale,black,2\n0,0,50,128,128,128,#656565,grayscale,gray,3\n0,0,100,255,255,255,#FFFFFF,grayscale,white,4\n30,90,100,255,140,25,#FF8C19,group,orange,1";

// Preference Saving

function loadPref(key,value) {
	var string = widget.preferenceForKey(key);
	if (string != null) {
		return string;
	} else {
		widget.setPreferenceForKey(value,key);
		return value;
	}
}

function loadPrefs() {
//	document.getElementById("H").value = parseInt(pref[0]);
//	document.getElementById("S").value = parseInt(pref[1]);
//	document.getElementById("V").value = parseInt(pref[2]);
//	document.getElementById("R").value = parseInt(pref[3]);
//	document.getElementById("G").value = parseInt(pref[4]);
//	document.getElementById("B").value = parseInt(pref[5]);
//	document.getElementById("X").value = pref[6];
	document.getElementById("sort").object.setSelectedIndex(prefSort);
	document.getElementById("location").value = prefLocation;
//	document.getElementById("groupTitle").value = prefGroup;
//	document.getElementById("nameTitle").value = prefName;

	updateAll();
	getLibrary();
}

function savePref(key,value) {
	if (window.widget) {
		widget.setPreferenceForKey(value,wid+key);
	}
}

function updatePrefs() {
	if (window.widget) {
		widget.setPreferenceForKey(pref[0],wid+"H");
		widget.setPreferenceForKey(pref[1],wid+"S");
		widget.setPreferenceForKey(pref[2],wid+"V");
		widget.setPreferenceForKey(pref[3],wid+"R");
		widget.setPreferenceForKey(pref[4],wid+"G");
		widget.setPreferenceForKey(pref[5],wid+"B");
		widget.setPreferenceForKey(pref[6],wid+"X");
		widget.setPreferenceForKey(prefSort,wid+"sort");
		widget.setPreferenceForKey(prefLocation,wid+"location");
		widget.setPreferenceForKey(prefGroup,wid+"group");
		widget.setPreferenceForKey(prefName,wid+"name");
	}
}

function erasePrefs() {
	if (window.widget) {
		widget.setPreferenceForKey(null,wid+"H");
		widget.setPreferenceForKey(null,wid+"S");
		widget.setPreferenceForKey(null,wid+"V");
		widget.setPreferenceForKey(null,wid+"R");
		widget.setPreferenceForKey(null,wid+"G");
		widget.setPreferenceForKey(null,wid+"B");
		widget.setPreferenceForKey(null,wid+"X");
		widget.setPreferenceForKey(null,wid+"sort");
		widget.setPreferenceForKey(null,wid+"location");
		widget.setPreferenceForKey(null,wid+"group");
		widget.setPreferenceForKey(null,wid+"name");
	}
}

// Basic Functions

function updateAll(event) {
	if (event != "HSV") {
		document.getElementById("H").value = parseInt(pref[0]);
		document.getElementById("S").value = parseInt(pref[1]);
		document.getElementById("V").value = parseInt(pref[2]);
	}
	if (event != "RGB") {
		document.getElementById("R").value = parseInt(pref[3]);
		document.getElementById("G").value = parseInt(pref[4]);
		document.getElementById("B").value = parseInt(pref[5]);
	}
	if (event != "HEX") {
		document.getElementById("X").value = pref[6];
	}
	if (document.getElementById("swatch")) document.getElementById("swatch").style.backgroundColor = pref[6];
	if (document.getElementById("swatchSave")) document.getElementById("swatchSave").style.backgroundColor = pref[6];

	document.getElementById("groupTitle").value = prefGroup;
	document.getElementById("nameTitle").value = prefName;
//	alert("update all");
}

function updateSort(event) {
	prefSort = document.getElementById("sort").object.getSelectedIndex();
}

function updateLocation(event) {
	prefLocation = document.getElementById("location").value;
}

function updateInput(event) {
	var data = parseFloat(event.target.value);
	var limit = 255;
	var increment = 8;
	var prefId = 6;

	switch (event.target.id) {
	case "H":
		prefId = 0;
		limit = 360;
		increment = 10;
		break;
	case "S":
		prefId = 1;
		limit = 100;
		increment = 10;
		break;
	case "V":
		prefId = 2;
		limit = 100;
		increment = 10;
		break;
	case "R":
		prefId = 3;
		break;
	case "G":
		prefId = 4;
		break;
	case "B":
		prefId = 5;
		break;
	default:
		increment = false;
		data = event.target.value.match(/([0-9a-f]{6})/i);
//		data = event.target.value.match(/^#?([0-9a-f]{6})$/i);
		if (data && event.keyCode>40) {
			pref[6] = "#"+data[1].toUpperCase();
			if (!data[0].match("#")) event.target.value = pref[6];
			HEXtoRGB();
			RGBtoHSV();
			return updateAll("HEX");
		} else {
			return false;
		}
	}

	if (event.keyCode == 38 && increment) {
		if (event.shiftKey == true) {
			data += increment;
			event.target.value = data;
		} else {
			data += 1;
			event.target.value = data;
		}
	} else if (event.keyCode == 40 && increment) {
		if (event.shiftKey == true) {
			data -= increment;
			event.target.value = data;
		} else {
			data -= 1;
			event.target.value = data;
		}
	}

	if (data>=0 && ((data % 1) == 0)) {
		if (data>limit) {
//			alert("met limit");
			data = limit;
			event.target.value = data;
		}
		pref[prefId] = data;
	} else {
//		alert("invalid");
		event.target.value = parseInt(pref[prefId]);
	}

	if (increment == 10) {
		HSVtoRGB();
		RGBtoHEX();
		return updateAll("HSV");
	} else {
		RGBtoHSV();
		RGBtoHEX();
		return updateAll("RGB");
	}
}



// Library management

function fromLibrary(event) {
	pref[0] = event[0];
	pref[1] = event[1];
	pref[2] = event[2];
	pref[3] = event[3];
	pref[4] = event[4];
	pref[5] = event[5];
	pref[6] = event[6];
	prefGroup = event[7];
	prefName = event[8];
	updateAll();
}

function addLibrary(event) {
	add = [pref[0],pref[1],pref[2],pref[3],pref[4],pref[5],pref[6],document.getElementById("groupTitle").value,document.getElementById("nameTitle").value,new Date().getTime()];
	getLibrary();
	showValues();
}

function editLibrary(event) {
	del = event;
	getLibrary();
}

function getLibrary(event) {
	var commandString = "cat "+prefLocation+"chromaLibrary.txt";
	widget.system(commandString, processLibrary).outputString;
}

function processLibrary(event) {
	if (busy) {
		return showFail();
	} else if (event.status>0) {
//		busy = false;
//		alert("processLibrary error = "+event.errorString);
		return showCreate();
	} else {
//		if (!event.outputString) return;
		event.outputString = event.outputString || libString;

		busy = true;
		libArray = event.outputString.split("\n");
		for(var i in libArray) {
			libArray[i] = libArray[i].split(",");
		}

		if (add) {
			if (!libArray[0][1]) {
				libArray = [""];
				libArray[0] = add;
			} else {
				libArray.push(add);
			}
			add = false;
		}

		if (del) {
			del = arrayMatch(libArray,9,del);
			if (del) libArray.splice(del,1);
			del = false;
		}

//		alert("libArray:\n"+libArray+"\nlength:\n"+libArray.length);

		if (libArray[1]) {
			switch (prefSort) {
			case 0:
				libArray.sort(sortName);
				break;
			case 1:
				libArray.sort(sortHue);
				break;
			case 2:
				libArray.sort(sortSaturation);
				break;
			case 3:
				libArray.sort(sortValue);
				break;
			case 4:
				libArray.sort(sortDate);
				break;
			default:
				alert("prefSort error:\n"+prefSort);
			}
		}

		listDataSource._rowData = libArray;
		list.object.reloadData();
		document.getElementById("scrollArea").object.refresh();
		busy = false;
		setLibrary();
	}
}

function arrayMatch(arr,ind,str) {
	for(var i in arr) {
		if (arr[i][ind] == str) return i;
	}
	return false;
}

function sortName(a, b) {
	var x = a[7].toLowerCase();
	var y = b[7].toLowerCase();
	if (x==y) x = a[8].toLowerCase(), y = b[8].toLowerCase();
	return (x < y) ? -1 : ((x > y) ? 1 : 0);
}

function sortHue(a, b){
	var x = a[7].toLowerCase();
	var y = b[7].toLowerCase();
	return (x < y) ? 1 : ((x > y) ? -1 : a[0] - b[0]);
}

function sortSaturation(a, b){
	var x = a[7].toLowerCase();
	var y = b[7].toLowerCase();
	return (x < y) ? 1 : ((x > y) ? -1 : a[1] - b[1]);
}

function sortValue(a, b){
	var x = a[7].toLowerCase();
	var y = b[7].toLowerCase();
	return (x < y) ? 1 : ((x > y) ? -1 : a[2] - b[2]);
}

function sortDate(a, b){
	return a[9] - b[9];
}

function setLibrary(event) {
	if (busy) return showFail();
	busy = true;
	libString = [];
	for(var i in libArray) {
		libString[i] = libArray[i].join(",");
	}
	libString = libString.join("\n");
	var myCommand = widget.system("cat > "+prefLocation+"chromaLibrary.txt", endHandler);
	myCommand.write(libString);
	myCommand.close();
	busy = false;
}

function createLibrary(event) {
//alert("createLibrary");
	setLibrary();
	getLibrary();
	showMain();
}

function endHandler(event) {
//alert("endHandler = "+event);
}

// Clipboard

function copy(value){
	widget.system("/usr/bin/osascript -e 'set the clipboard to \"" + value + "\"'", null);
}

// Key listeners

function selectIt(event) {
	if(event.target){
		event = event.target
	}
//	event.focus();
	event.select();
}



//// LIST BOX

var _this = [];

// This object implements the dataSource methods for the list.
var listDataSource = {

	// Sample data for the content of the list. 
	// Your application may also fetch this data remotely via XMLHttpRequest.
	_rowData: [["empty library"]],

	// The List calls this method to find out how many rows should be in the list.
	numberOfRows: function() {
		return this._rowData.length;
	},

	// The List calls this method once for every row.
	prepareRow: function(rowElement, rowIndex, templateElements) {
		// templateElements contains references to all elements that have an id in the template row.
		// Ex: set the value of an element with id="label".
		if (!this._rowData[rowIndex][9]) {
			templateElements.label.innerText = this._rowData[rowIndex];
			templateElements.labelHSV.innerText = "";
			templateElements.labelRGB.innerText = "";
			templateElements.labelHEX.innerText = "";
			templateElements.swatchList.style.opacity = 0;
		} else {
			if (templateElements.label) {
				templateElements.label.innerText = this._rowData[rowIndex][7];
				templateElements.label.style.opacity = 0;
			}
			if (templateElements.labelHSV) {
				var tempHSV = parseInt(this._rowData[rowIndex][0])+" "+parseInt(this._rowData[rowIndex][1])+" "+parseInt(this._rowData[rowIndex][2]);
				templateElements.labelHSV.innerText = tempHSV;
				templateElements.labelHSV.onclick = function(event) { copy(tempHSV) };
			}
			if (templateElements.labelRGB) {
				var tempRGB = parseInt(this._rowData[rowIndex][3])+" "+parseInt(this._rowData[rowIndex][4])+" "+parseInt(this._rowData[rowIndex][5]);
				templateElements.labelRGB.innerText = tempRGB;
				templateElements.labelRGB.onclick = function(event) { copy(tempRGB) };
			}
			if (templateElements.labelHEX) {
				templateElements.labelHEX.innerText = this._rowData[rowIndex][6];
				templateElements.labelHEX.onclick = function(event) { copy(_this._rowData[rowIndex][6]) };
			}
			if (templateElements.swatchList) {
				templateElements.swatchList.style.backgroundColor = this._rowData[rowIndex][6];
			}
			if (templateElements.imgUse) {
				templateElements.imgUse.onclick = function(event) { fromLibrary(_this._rowData[rowIndex]) };
			}
			if (templateElements.imgDelete) {
				templateElements.imgDelete.onclick = function(event) { editLibrary(_this._rowData[rowIndex][9]) };
			}
		}

		_this = this;
//		rowElement.onclick = function(event) { alert(_this._rowData[0]); };

		// Assign a click event handler for the row.
//		rowElement.onclick = function(event) {
//			alert("Row "+rowIndex);
//		};
	}
};



// Conversion Processes

/*
 * Converts an RGB color value to HSV. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and v in the set [0, 1].
 */
function RGBtoHSV(r, g, b){
	r = r || pref[3];
	g = g || pref[4];
	b = b || pref[5];

	r = r/255, g = g/255, b = b/255;
	var max = Math.max(r, g, b), min = Math.min(r, g, b);
	var h, s, v = max;

	var d = max - min;
	s = max == 0 ? 0 : d / max;

	if(max == min){
		h = 0; // achromatic
	}else{
		switch(max){
			case r: h = (g - b) / d + (g < b ? 6 : 0); break;
			case g: h = (b - r) / d + 2; break;
			case b: h = (r - g) / d + 4; break;
		}
		h /= 6;
	}

	h = h*360, s = s*100, v = v*100;
	pref[0] = h;
	pref[1] = s;
	pref[2] = v;
	return [h, s, v];
}

/*
 * Converts an HSV color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes h, s, and v are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 */
function HSVtoRGB(h, s, v){
	h = h || pref[0]/360;
	s = s || pref[1]/100;
	v = v || pref[2]/100;
	var r, g, b;

	var i = Math.floor(h * 6);
	var f = h * 6 - i;
	var p = v * (1 - s);
	var q = v * (1 - f * s);
	var t = v * (1 - (1 - f) * s);

	switch(i % 6){
		case 0: r = v, g = t, b = p; break;
		case 1: r = q, g = v, b = p; break;
		case 2: r = p, g = v, b = t; break;
		case 3: r = p, g = q, b = v; break;
		case 4: r = t, g = p, b = v; break;
		case 5: r = v, g = p, b = q; break;
	}

	r = r*255, g = g*255, b = b*255;
	pref[3] = r;
	pref[4] = g;
	pref[5] = b;
	return [r, g, b];
}

function RGBtoHEX(rgb) {
	rgb = rgb || [pref[3],pref[4],pref[5]];
	var hex = [];
	hex[0] = DECtoHEX(parseInt(rgb[0]));
	hex[1] = DECtoHEX(parseInt(rgb[1]));
	hex[2] = DECtoHEX(parseInt(rgb[2]));

	pref[6] = hex = "#"+(hex[0]+""+hex[1]+""+hex[2]).toUpperCase();
	return hex;
}

function DECtoHEX(dec) {
	return dec.toString(16);
}

function HEXtoRGB(hex) {
	hex = hex || pref[6];
	hex = hex.replace("#","");
	var r = HEXtoDEC(hex.substring(0,2));
	var g = HEXtoDEC(hex.substring(2,4));
	var b = HEXtoDEC(hex.substring(4,6));

	pref[3] = r;
	pref[4] = g;
	pref[5] = b;
	return [r, g, b];
}

function HEXtoDEC(hex) {
	return parseInt(hex, 16);
}



// CurrentView animations

function showMain(event) {
	document.getElementById("stack").object.setCurrentView("main", false, true);
}

function showSuccess(event) {
	document.getElementById("stack").object.setCurrentView("success", true, true);
}

function showFail(event) {
	document.getElementById("stack").object.setCurrentView("fail", true, true);
}

function showCreate(event) {
	document.getElementById("stack").object.setCurrentView("create", true, true);
}

function showUpdate(event) {
	document.getElementById("stack").object.setCurrentView("update", true, true);
}

function showValues(event) {
	document.getElementById("stack2").object.setCurrentView("values", true, true);
}

function showNames(event) {
	document.getElementById("stack2").object.setCurrentView("names", false, true);
}

// Element animations

function buttonOver(event) {
	var itemToFadeIn = event.target;
	var fadeHandler = function(a, c, s, f){ itemToFadeIn.style.opacity = c; };
	new AppleAnimator(200, 5, 0.15, 0.65, fadeHandler).start();
}

function buttonOut(event) {
	var itemToFadeIn = event.target;
	var fadeHandler = function(a, c, s, f){ itemToFadeIn.style.opacity = c; };
	new AppleAnimator(400, 10, 0.65, 0.15, fadeHandler).start();
}


// Get Key Value

function getKeyValue(plist, key) {
	var infoPlist = new XMLHttpRequest();
	infoPlist.open("GET", plist, false);
	infoPlist.send(null);
	infoPlist = infoPlist.responseText.replace(/(<([^>]+)>)/ig,"").replace(/\t/ig,"").split("\n");
	for (var i=0; i<infoPlist.length; i++)
		if (infoPlist[i] == key) return infoPlist[i+1];
	return false;
}

// Auto Update

function versionCheck(event) {
	var request = new XMLHttpRequest();
	var address = "http://iaian7.com/files/dashboard/chroma/version.php?RandomKey=" + Date.parse(new Date());
//	alert(address);
	request.open("GET", address,false);
	request.send(null);
	var versions = request.responseText.split("\n");

	var bundleVersion = getKeyValue("Info.plist", "CFBundleVersion"); 
	var websiteVersion = versions[0];
//	alert("bundleVersion: "+bundleVersion);
//	alert("websiteVersion: "+websiteVersion);

	if (websiteVersion != bundleVersion) {
		document.getElementById("newVersion").innerHTML = "version "+versions[0]+"<br/>"+versions[1];
		showUpdate();
	} else {
		alert("you have an up to date version, or there's been an error");
	}
}

// Download File

function versionDownload() {
	widget.openURL("http://iaian7.com/files/dashboard/chroma/Chroma.zip");
	showMain();
}

// Visit the website

function iaian7(event)
{
	widget.openURL("http://iaian7.com/dashboard/chroma");
}